# 线程
1、什么是进程？什么是线程？

进程是一个应用程序（1个进程是一个软件）。线程是一个进程中的执行场景/执行单元。一个进程可以启动多个线程。

2、对于java程序来说，当在DOS命令窗口中输入：java HelloWorld 回车之后。

会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。

最起码，现在的java程序中至少有两个线程并发，
		
一个是垃圾回收线程，一个是执行main方法的主线程。

3、进程A和进程B的内存独立不共享。

在java语言中：线程A和线程B，堆内存和方法区内存共享。但是栈内存独立，一个线程一个栈。
			
假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。

java中之所以有多线程机制，目的就是为了提高程序的处理效率。

4、使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈。

5、单核的CPU表示只有一个大脑：不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是：多个事情同时在做！！！！！

## 实现线程的方式

1、第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。
```java
		// 定义线程类
		public class MyThread extends Thread{
			public void run(){
			
			}
		}
		// 创建线程对象
		MyThread t = new MyThread();
		// 启动线程。
		t.start();
```
2、编写一个类，实现java.lang.Runnable接口，实现run方法。
```java
// 定义一个可运行的类
		public class MyRunnable implements Runnable {
			public void run(){
			
			}
		}
		// 创建线程对象
		Thread t = new Thread(new MyRunnable());
		// 启动线程
		t.start();
```
采用匿名内部类，匿名内部类会直接实现接口，这在某些条件下会给我们带来便捷性。
```java
Thread myThread=new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("分支线程==》"+i);
                }
            }
        });
        myThread.start();
```
第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活。

## 线程的一些方法
1、怎么获取当前线程对象？
    Thread t = Thread.currentThread();
    返回值t就是当前线程。

2、获取线程对象的名字
    String name = 线程对象.getName();

3、修改线程对象的名字
    线程对象.setName("线程名字");

4、当线程没有设置名字的时候，默认的名字有什么规律？（了解一下）
    Thread-0，
    Thread-1，
    Thread-2，
    Thread-3，
    .....
## 线程睡觉与打断、杀死线程
关于线程的sleep方法：
static void sleep(long millis)

1、静态方法：Thread.sleep(1000);

2、参数是毫秒

3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。

这行代码出现在A线程中，A线程就会进入休眠。

这行代码出现在B线程中，B线程就会进入休眠。

4、Thread.sleep()方法，可以做到这种效果：

间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。

5、怎么叫醒一个正在睡眠的线程？？ t.interrupt();

6、面试题：
```java
public class ThreadTest07 {
    public static void main(String[] args) {
        // 创建线程对象
        Thread t = new MyThread3();
        t.setName("t");
        t.start();

        // 调用sleep方法
        try {
            // 问题：这行代码会让线程t进入休眠状态吗？
            t.sleep(1000 * 5); // 在执行的时候还是会转换成：Thread.sleep(1000 * 5);
                                     // 这行代码的作用是：让当前线程进入休眠，也就是说main线程进入休眠。
                                     // 这样代码出现在main方法中，main线程睡眠。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 5秒之后这里才会执行。
        System.out.println("hello World!");
    }
}

class MyThread3 extends Thread {
    public void run(){
        for(int i = 0; i < 10000; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```

7、在java中怎么强行终止一个线程的执行。

这种方式存在很大的缺点：容易丢失数据。因为这种方式是直接将线程杀死了，线程没有保存的数据将会丢失。不建议使用。

t.stop();

8、怎么合理的终止一个线程的执行？

```java
public class ThreadTest10 {
    public static void main(String[] args) {
        MyRunable4 r = new MyRunable4();
        Thread t = new Thread(r);
        t.setName("t");
        t.start();

        // 模拟5秒
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 终止线程
        // 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。
        r.run = false;
    }
}

class MyRunable4 implements Runnable {

    // 打一个布尔标记
    boolean run = true;

    @Override
    public void run() {
        for (int i = 0; i < 10; i++){
            if(run){
                System.out.println(Thread.currentThread().getName() + "--->" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }else{
                // return就结束了，你在结束之前还有什么没保存的。
                // 在这里可以保存呀。
                //save....

                //终止当前线程
                return;
            }
        }
    }
}

```
## 线程调度

1、关于线程对象的生命周期？
新建状态、就绪状态、运行状态、阻塞状态、死亡状态
![线程生命周期](/src/线程生命周期.png)

关于线程的调度

1.1、常见的线程调度模型有哪些？

抢占式调度模型：
那个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。java采用的就是抢占式调度模型。

均分式调度模型：
平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。平均分配，一切平等。有一些编程语言，线程调度模型采用的是这种方式。

1.2、java中提供了哪些方法是和线程调度有关系的呢？

实例方法：

void setPriority(int newPriority) 设置线程的优先级

int getPriority() 获取线程优先级

最低优先级1、默认优先级是5、最高优先级10，优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的。）

静态方法：

static void yield()  让位方法，暂停当前正在执行的线程对象，并执行其他线程。

yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。

yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。

注意：在回到就绪之后，有可能还会再次抢到。

实例方法：

void join()  

合并线程
```java
class MyThread1 extends Thread {
public void doSome(){
	MyThread2 t = new MyThread2();
	t.join(); // 当前线程进入阻塞，t线程执行，直到t线程结束。当前线程才可以继续。
}
}

class MyThread2 extends Thread{

}
```
2、关于多线程并发环境下，数据的安全问题。

2.1、为什么这个是重点？

以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了。这些代码我们都不需要编写。

最重要的是：你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。（重点：*****）

2.2、什么时候数据在多线程并发的环境下会存在安全问题呢？

三个条件：

条件1：多线程并发。

条件2：有共享数据。

条件3：共享数据有修改的行为。

满足以上3个条件之后，就会存在线程安全问题。

2.3、怎么解决线程安全问题呢？

当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？

线程排队执行。（不能并发）。用排队执行解决线程安全问题。这种机制被称为：线程同步机制。

专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行。

怎么解决线程安全问题呀？
使用“线程同步机制”。

线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。

2.4、说到线程同步这块，涉及到这两个专业术语：

异步编程模型：
线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型。其实就是：多线程并发（效率较高。）

异步就是并发。

同步编程模型：
线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。效率较低。线程排队执行。

同步就是排队。
