# 线程
1、什么是进程？什么是线程？

进程是一个应用程序（1个进程是一个软件）。线程是一个进程中的执行场景/执行单元。一个进程可以启动多个线程。

2、对于java程序来说，当在DOS命令窗口中输入：java HelloWorld 回车之后。

会先启动JVM，而JVM就是一个进程。JVM再启动一个主线程调用main方法。同时再启动一个垃圾回收线程负责看护，回收垃圾。

最起码，现在的java程序中至少有两个线程并发，
		
一个是垃圾回收线程，一个是执行main方法的主线程。

3、进程A和进程B的内存独立不共享。

在java语言中：线程A和线程B，堆内存和方法区内存共享。但是栈内存独立，一个线程一个栈。
			
假设启动10个线程，会有10个栈空间，每个栈和每个栈之间，互不干扰，各自执行各自的，这就是多线程并发。

java中之所以有多线程机制，目的就是为了提高程序的处理效率。

4、使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈。

5、单核的CPU表示只有一个大脑：不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是：多个事情同时在做！！！！！

## 实现线程的方式

1、第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法。
```java
		// 定义线程类
		public class MyThread extends Thread{
			public void run(){
			
			}
		}
		// 创建线程对象
		MyThread t = new MyThread();
		// 启动线程。
		t.start();
```
2、编写一个类，实现java.lang.Runnable接口，实现run方法。
```java
// 定义一个可运行的类
		public class MyRunnable implements Runnable {
			public void run(){
			
			}
		}
		// 创建线程对象
		Thread t = new Thread(new MyRunnable());
		// 启动线程
		t.start();
```
采用匿名内部类，匿名内部类会直接实现接口，这在某些条件下会给我们带来便捷性。
```java
Thread myThread=new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 1000; i++) {
                    System.out.println("分支线程==》"+i);
                }
            }
        });
        myThread.start();
```
第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活。

## 线程的一些方法
1、怎么获取当前线程对象？
    Thread t = Thread.currentThread();
    返回值t就是当前线程。

2、获取线程对象的名字
    String name = 线程对象.getName();

3、修改线程对象的名字
    线程对象.setName("线程名字");

4、当线程没有设置名字的时候，默认的名字有什么规律？（了解一下）
    Thread-0，
    Thread-1，
    Thread-2，
    Thread-3，
    .....
## 线程睡觉与打断、杀死线程
关于线程的sleep方法：
static void sleep(long millis)

1、静态方法：Thread.sleep(1000);

2、参数是毫秒

3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用。

这行代码出现在A线程中，A线程就会进入休眠。

这行代码出现在B线程中，B线程就会进入休眠。

4、Thread.sleep()方法，可以做到这种效果：

间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。

5、怎么叫醒一个正在睡眠的线程？？ t.interrupt();

6、面试题：
```java
public class ThreadTest07 {
    public static void main(String[] args) {
        // 创建线程对象
        Thread t = new MyThread3();
        t.setName("t");
        t.start();

        // 调用sleep方法
        try {
            // 问题：这行代码会让线程t进入休眠状态吗？
            t.sleep(1000 * 5); // 在执行的时候还是会转换成：Thread.sleep(1000 * 5);
                                     // 这行代码的作用是：让当前线程进入休眠，也就是说main线程进入休眠。
                                     // 这样代码出现在main方法中，main线程睡眠。
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 5秒之后这里才会执行。
        System.out.println("hello World!");
    }
}

class MyThread3 extends Thread {
    public void run(){
        for(int i = 0; i < 10000; i++){
            System.out.println(Thread.currentThread().getName() + "--->" + i);
        }
    }
}
```

7、在java中怎么强行终止一个线程的执行。

这种方式存在很大的缺点：容易丢失数据。因为这种方式是直接将线程杀死了，线程没有保存的数据将会丢失。不建议使用。

t.stop();

8、怎么合理的终止一个线程的执行？

```java
public class ThreadTest10 {
    public static void main(String[] args) {
        MyRunable4 r = new MyRunable4();
        Thread t = new Thread(r);
        t.setName("t");
        t.start();

        // 模拟5秒
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 终止线程
        // 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。
        r.run = false;
    }
}

class MyRunable4 implements Runnable {

    // 打一个布尔标记
    boolean run = true;

    @Override
    public void run() {
        for (int i = 0; i < 10; i++){
            if(run){
                System.out.println(Thread.currentThread().getName() + "--->" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }else{
                // return就结束了，你在结束之前还有什么没保存的。
                // 在这里可以保存呀。
                //save....

                //终止当前线程
                return;
            }
        }
    }
}

```
## 线程调度

1、关于线程对象的生命周期？
新建状态、就绪状态、运行状态、阻塞状态、死亡状态
